from dolfin import *

dim = 2

# Mesh
mesh 	= RectangleMesh(0.0,0.0,5.0,1.0, 100, 20,"crossed")
bndry 	= FacetFunction("size_t", mesh)

# Boundary description

def left(x,on_boundary):
    return bndry and near(x[0],0.0) 

def right(x,on_boundary):
    return bndry and near(x[0],5.0)

def bottom(x,on_boundary):
    return bndry and near(x[1],0.0)

def top(x,on_boundary):
    return bndry and near(x[1],1.0)

# Function spaces
V = VectorFunctionSpace(mesh, 'DG', 1)
Q = FunctionSpace(mesh, 'DG', 0)
W = MixedFunctionSpace([V,Q])


dirichlet 	= Expression(("1.0", "0.0"), t = 0.0)
u_IN		= Expression(("1.0", "0.0"), t = 0.0)
u_OUT		= Expression(("1.0", "0.0"), t = 0.0)

bc_Dir = DirichletBC( W.sub(0), dirichlet, bottom or top)
bc_IN  = DirichletBC( W.sub(0), u_IN,	   left)
bc_OUT = DirichletBC( W.sub(0), u_OUT, 	   right)
bcs = [bc_Dir, bc_IN, bc_OUT]

# Unknown and test functions
w 	= Function(W)
(u, p)  = split(w)
(v, q)  = TestFunctions(W)
u_1	= Function(V) # velocity from previous time step

# Problem parameters
T_end		= 1.0
dt		= 0.1
u0		= Expression(("1.0", "0.0"))
f_rhs 		= Expression(("0.0", "0.0"), t = 0.0)

nu	= 0.001
sigma	= 1.0

# Variational formulation
n 	= FacetNormal(mesh)
ds 	= Measure("ds", subdomain_data = bndry)
I 	= Identity(u.geometric_dimension())
D 	= 0.5*(grad(u) + grad(u).T)
F 	= D
def a(u,v):
	M = inner(grad(u),grad(v))*dx - inner(avg(grad(u)*n),jump(v))*dS 
	return M

def J(u,v):
	M = sigma*inner(jump(u),jump(v))*dS
	return M

def b(p,v):
	M = -p*div(v)*dx  + dot(avg(p*n),jump(v))*dS
	return M

def c(u,w,v):	
	P = avg(dot(w,n))
	H = conditional(P < 0.0, dot(u('+'),w('+')), -dot(u('-'),w('-')))
	M = -0.5*inner(grad(v)*u,w)*dx + inner(0.5*H*n('+'),jump(v))*dS
	return M

def L(v):
	M = inner(f_rhs,v)*dx 
	return M

T = (1/dt)*inner(u - u_1,v)*dx + a(u,v) + J(u,v) + b(p,v) + b(q,u) + c(u,u_1,v) - L(v)

u_1.assign(interpolate(u0,V))

# Solution

ufile = File("u.xdmf")
pfile = File("p.xdmf")
t = dt
u_1.rename("u", "velocity")
ufile << u_1

while t<=T_end:
	dirichlet.t 	= t
	u_IN.t		= t
	u_OUT.t		= t	
	solve(T==0,w,bcs)
	(u,p) = w.split(True)
	u_1.assign(u)		
	u.rename("u", "velocity")
	p.rename("p", "pressure")
	ufile << u
	pfile << p
	t += float(dt)
	
plot(u_1)
plot(p)
interactive()	

 


